# 第十章 数组和指针

## 数组

- 创建只读数组，应该用const声明和初始化数组
- 使用数组前必须先初始化它。在使用数组元素之前， 必须先给它们赋初值。
若不赋值，编译器使用的值是内存相应位置上的现有值
- 当初始化列表中的值少于数组元素个数 时，编译器会把剩余的元素都初始化为0。
```
/* day_mon2.c -- 让编译器计算元素个数*/

#include <stdio.h>
int main(void)
{
    const int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31}; //1
    int index;
    for (index = 0; index < sizeof(days) / sizeof(days[0])/*2*/; index++)
        printf("%2d月有%2d天。\n", index+1, days[index]);
    return 0;
}

//1 编译器会根据初始化列表中的 项数来确定数组的大小。

/*2
sizeof运算符给出它的运算对象的大小（以字节为单 位）。
所以sizeof days是整个数组的大小（以字节为单位），
sizeof day[0]是 数组中一个元素的大小（以字节为单位）。
整个数组的大小除以单个元素的 大小就是数组元素的个数。
*/

```

### 指定初始化器 C99

例子：只初始化最后一个元素

传统的语法：`int arr[6] = {0,0,0,0,0,212};`

C99：`int arr[6] = {[5]=212};`  

```
/*designate.c -- 使用指定初始化器*/

#include <stdio.h>
#define MONTHS 12

int main(void)
{
    int days[MONTHS] = { 31, 28, [4] = 31, 30, 31, [1] = 29}; //1
    for (short i = 0; i < MONTHS; i++)
    {
        printf("%2d  %d\n", i + 1, days[i]);
    }
    return 0;
}
/*
1  31
 2  29
 3  0
 4  0
 5  31
 6  30
 7  31
 8  0
 9  0
10  0
*/
```

[4] = 31,30,31，在days[4]被初 始化为31后，days[5]和days[6]将分别被初始化为30和31

再次初 始化指定的元素，那么最后的初始化将会取代之前的初始化
[1] = 29  days[1]28被修改为了29

如果未指定元素大小
`int stuff[] = {1, [6]=23};` 7个元素大小
`int stuff[] = {1, [6]=4,9,10};` 9个元素大小

### 数组下标越界

使用越界的数组下标会导致程序改变其他变量的值。 不同的编译器运行该程序的结果可能不同，有些会导致程序异常中止。

C 语言为何会允许这种麻烦事发生？这要归功于 C 信任程序员的原 则。不检查边界，C 程序可以运行更快。


## 多维数组
### 二维数组
`float rain[5][12]; `
// 内含5个数组元素的数组，每个数组元素内含12个 float类型的元素

![](%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/DB89D722-AC13-46B4-A50C-D0438C6B6FC7.png)

### 更多维

`int box[10][20][30]; `
可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数 组想象成一叠数据表。例如，把上面声明的三维数组box想象成由10个二维 数组（每个二维数组都是20行30列）堆叠起来。

通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套 循环。对于其他多维数组，以此类推。

## 指针和数组

如果flizny是一个数组，下面的语句成立：
flizny == &flizny[0]; // 数组名是该数组首元素的地址

在C中，指针加1指的是增加一个存储单元。对数组而言，这意味 着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。即，指针加1，指针的值递增它所指向类型的大小（以字节为单位）。

![](%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/8B4CD2D4-9654-4D00-B2A1-88F1B06F41A4.png)


`dates + 2 == &date[2] // 相同的地址 `

`*(dates + 2) == dates[2] // 相同的值`

`*(dates + 2) // dates第3个元素的值`

`*dates + 2 // dates第1个元素的值加2`


- 数组表示法和指针表示法
days是数组首元素的地址，days + index是元素days[index]的地 址，
而*(days + index)则是该元素的值，相当于days[index]

## 函数、数组和指针

`int sum(int *ar, int n) | int sum(int *, int)`

`int sum(int ar[], int n) | int sum(int [], int)`

Int *ar形式和int ar[]形式都表示ar是一个指向int的指针。
但是，i ~nt ar[]只 能用于声明形式参数~ 。
第2种形式（int ar[]）提醒读者指针ar指向的不仅仅 一个int类型值，还是一个int类型数组的元素。

- 使用指针形参

```
/*sum_arr2.c -- 数组元素之和*/

#include <stdio.h>
#define SIZE 10

int sump(int *start, int *end);
int main(void)
{
    int marbles[SIZE] = { 20, 10, 5, 39, 4, 16, 19, 26, 31, 20 };
    long answer;
    answer = sump(marbles, marbles + SIZE);
    printf("marbles数组元素之和等于 %ld", answer);
    return 0;
}

/*使用指针算法*/
int sump(int *start, int *end)
{
    int total = 0;
    while (start < end) //1
    {
        total += *start; // 把数组元素的值加起来
        start++; // 让指针指向下一个元素
        //2
        // total += *start++;
    }
    return total;
}
```

**1**
循环最后处理的一个元素是end所指向位置的前一个元素。
这意味着end指向的位置实际上在数组最后一个元素的后面。
C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。
这使得 while循环的测试条件是有效的，因为 start在循环中最后的值是end。
注意，使用这种“越界”指针的函数调用更为简洁：
 answer = sump(marbles, marbles + SIZE);

**2**
还可以把循环体压缩成一行代码：
    total += *start++;
一元运算符*和++的优先级相同，但结合律是从右往左，所以start++先 求值，然后才是*start。
使用start++而不是++start，意味着先把指针指向位置上的值加到total上，然 后再递增指针

## 指针操作

```
/* order.c -- 指针运算中的优先级*/

#include <stdio.h>
int data[2] = {100, 200};
int moredata[2] = {300, 400};

int main(void)
{
    int *p1, *p2, *p3;
    p1 = p2 = data;
    p3 = moredata;

    printf(" *p1=%d, *p2=%d, *p3=%d\n", *p1, *p2, *p3); // 100 100 300
    printf(" *p1++ = %d, *++p2 = %d, (*p3)++ = %d\n", *p1++, *++p2, (*p3)++);// 100 200 301 ❌
    printf(" *p1=%d, *p2=%d, *p3=%d\n", *p1, *p2, *p3); //200 200 300 ❌
    return 0;
}

/*
 *p1=100, *p2=100, *p3=300
 *p1++ = 100, *++p2 = 200, (*p3)++ = 300
 *p1=200, *p2=200, *p3=301
*/
(*p3)++ ，打印时先取*p3，然后再做++运算

```

- 赋值：把地址赋给指针。例如，用数组名、带地址运算符（&）的 变量名、另一个指针进行赋值。

- 解引用：*运算符给出指针指向地址上储存的值。

- 取址：指针变量也有自己的地址和值。

- 指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针相加。

- 指针减去一个整数：如果相减的结果超出了初始指针所 指向数组的范围，计算结果则是未定义的。

- 递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个 元素。

- 递减指针：递增指向数组元素的指针可以让该指针移动至数组的上一个 元素。

- 指针求差：求差的两个指针分别指向 同一个数组的不同元素，通过计算求出两元素之间的距离。

- 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。

### 千万不要解引用未初始化的指针

Int * pt;// 未初始化的指针 
*pt = 5; // 严重的错误  这可能不会出什么 错，也可能会擦写数据或代码，或者导致程序崩溃。

切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。
因此， 在使用指针之前，必须先用已分配的地址初始化它。
例如，可以用一个现有 变量的地址初始化该指针（使用带指针形参的函数时，就属于这种情况）。
或者还可以使用第12章将介绍的malloc()函数先分配内存。
无论如何，使用 指针时一定要注意，不要解引用未初始化的指针！


## 保护数组中的数据
如果函数的意图不是修改数组中的数据内容，那么在函数 原型和函数定义中声明形式参数时应使用关键字const。
`int sum(const int ar[], int n);` 函数原型
这里一定要理解，这样使用const并不是要求原数组是常量，而是该函 数在处理数组时将其视为常量，不可更改。

一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用 const；.
如果编写的函数不用修改数组，那么在声明数组形参时最好使用 const。

- const数组
`const int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31};`




- 指针的初始化和赋值
Const指针可以由const数据或非const数据的地址赋值
```
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5}; 
const double locked[4] = {0.08, 0.075, 0.0725, 0.07}; 
const double * pc = rates; // 有效 
pc = locked; //有效 
pc = &rates[3]; //有效
```


//普通指针只能由非const数据的地址赋值
```
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5}; 
const double locked[4] = {0.08, 0.075, 0.0725, 0.07}; 
double * pnc = rates; // 有效 
pnc = locked; // 无效 
pnc = &rates[3]; // 有效 

```

- const指针不能用于改变值

double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double * pd = rates; // pd指向数组的首元素

//把pd指向的double类型的值声明为const，这表明不能使用pd 来更改它所指向的值：
// 指向的值不可修改
*pd = 29.8; //不允许 
pd[2] = 222.2; //不允许  

// 指针可修改
pd++; /* 让pd指向rates[1] — 没问题 */

- 可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地 址。
值可修改，指针不可修改
```
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5}; double * const pc = rates; // pc指向数组的开始 
pc = &rates[2]; // 不允许，因为该指针不能指向别处 
*pc = 92.99; // 没问题 — 更改rates[0]的值 
```


最后，在创建指针时还可以使用const两次，
该指针既不能更改它所指 向的地址，
也不能修改指向地址上的值：
```
 double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
 const double * const pc = rates; 
 pc = &rates[2]; //不允许 
 *pc = 92.99; //不允许
```


## 指针和多维数组

`int zippo[4][2]` 

zippo是该数组首元素的地址，即是第一个数组(内含两个int值)的地址。
即zippo的值和&zippo[0]的值相同。

而zippo[0]本身是数组，所以，zippo[0]的值和&zippo[0][0] 的值相同。

但是， zippo+1 和 zippo[0]+1的值不同。

解引用：
因为zippo[0]是该数组首元素 zippo[0][0] 的地址
所以，*(zippo[0]) 表示存储在zippo[0][0]上的值

*zippo是数组首元素zippo[0]的值，zippo[0]本身是一个int类型值的地址为 &zippo[0][0]
所以*zippo就是&zippo[0][0]
所以**zippo 就是 *&zippo[0][0]
所以 **zippo 就是 zippo[0][0] ,即一个int类型的值。
简而言之，zippo是地址的地址，解引用两次才能获得原始值。

地址的地址或指针的指针就是双重间接的例子

代码示例
```

/*指针相关加深*/
#include <stdio.h>

int main(void)
{
    int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1, 3 }, { 5, 7 } };
    printf("   zippo = %p, zippo + 1 = %p\n",
    zippo, zippo+1);

    printf("zippo[0] = %p, zippo[0] + 1 = %p\n",
    zippo[0], zippo[0]+1);

    printf("  *zippo=%p, *zippo+1=%p\n", *zippo, *zippo+1);

    printf("zippo[0][0] = %d\n", zippo[0][0]);

    printf("  *zippo[0] = %d\n", *zippo[0]);

    printf(" **zippo = %d\n", **zippo);

    printf("  zippo[2][1] = %d\n", zippo[2][1]);

    printf("*(*(zippo+2)+1) = %d\n", *(*(zippo+2)+1));

    return 0;
}

zippo = 0x7ffee2bae580, zippo + 1 = 0x7ffee2bae588
zippo[0] = 0x7ffee2bae580, zippo[0] + 1 = 0x7ffee2bae584
*zippo=0x7ffee2bae580, *zippo+1=0x7ffee2bae584
zippo[0][0] = 2
*zippo[0] = 2
**zippo = 2
zippo[2][1] = 3
*(*(zippo+2)+1) = 3
```


![](%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/4EEA4C97-0E2A-4CBD-A867-FC0F9A5C0E62.png)

![](%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/A4B83F1C-E70B-438D-97FC-73C994CCDC0E.png)


### 指向多维数组的指针

`int (*pz)[2];` // pz指向一个内含两个int类型值的数组
*先与pz结合，因此声明的是一个指向数组（内含两个int类型的 值）的指针。


`int *pax[2];`  // pax是一个内含两个指针元素的数组，每个元素都指 向int的指针
由于[]优先级高，先与pax结合，所以pax成为一个内含两个元素的数 组。然后*表示pax数组内含两个指针。最后，int表示pax数组中的指针都指 向int类型的值。

```
int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1, 3 }, { 5, 7 } }; 
int(*pz)[2];
pz = zippo; 
...
printf("*(*(pz+2) + 1) = %d\n", 
```

总结
`zippo[m][n] == *(*(zippo + m) + n) `
`pz[m][n] == *(*(pz + m) + n)`

### 指针的兼容性

```c
两个指针都是指向不同的类型,会导致赋值无效
    int * pt; 
    int (*pa)[3]; 
    int ar1[2][3];
    int ar2[3][2]; 
    int **p2; // 一个指向指针的指针

    pt = &ar1[0][0]; // 都是指向int的指针 
    pt = ar1[0]; // 都是指向int的指针 
    pt = ar1; // 无效 
    pa = ar1; // 都是指向内含3个int类型元素数组的指针 
    pa = ar2; // 无效 
    p2 = &pt; // both pointer-to-int *  都是指向指针的指针
    *p2 = ar2[0]; // 都是指向int的指针 
    p2 = ar2; // 无效
    //变量p2是指向指针的指针，它指向的指 针指向int，
    //而ar2是指向数组的指针，该数组内含2个int类型的元素。
    //所以， p2和ar2的类型不同，不能把ar2赋给p2。
    
    //但是，*p2是指向int的指针，与 ar2[0]兼容。
    //因为ar2[0]是指向该数组首元素（ar2[0][0]）的指针，所以 ar2[0]也是指向int的指针。

```

```c
一般而言，多重解引用让人费解。
    int x = 20; 
    const int y = 23; 
    int * p1 = &x; 
    const int * p2 = &y; 
    const int ** pp2; 
    
    p1 = p2; // 不安全 -- 把const指针赋给非const指针 
    p2 = p1; // 有效 -- 把非const指针赋给const指针 
    pp2 = &p1; // 不安全 –- 嵌套指针类型赋值

    前面提到过，把const指针赋给非const指针不安全，
    因为这样可以使用新的指针改变const指针指向的数据。
    
    但是把非const指针赋给const指针没问题，
    前提是只进行一级解引用： p2 = p1; // 有效 -- 把非const指针赋给const指针 
    但是进行两级解引用时，这样的赋值也不安全，例如，考虑下面的代码：
    const int **pp2; 
    int *p1; 
    const int n = 13;
    
    pp2 = &p1; // 允许，但是这导致const限定符失效（根据第1行代码， 不能通过*pp2修改它所指向的内容）
    *pp2 = &n; // 有效，两者都声明为const，但是这将导致p1指向 n（*pp2已被修改）
    *p1 = 10; //有效，但是这将改变n的值（但是根据第3行代码，不能修改n 的值）
    发生了什么？如前所示，标准规定了通过非const指针更改const数据是 未定义的。例如，在Terminal中（OS X对底层UNIX系统的访问）使用gcc编 译包含以上代码的小程序，导致n最终的值是13，但是在相同系统下使用 clang来编译，n最终的值是10。两个编译器都给出指针类型不兼容的警告。 当然，可以忽略这些警告，但是最好不要相信该程序运行的结果，这些结果 都是未定义的。

```


### 函数和多维数组

函数中使用二维数组形参
```c
#define COLS 4
void sum_rows(int ar[][COLS], int rows);
void sum_cols(int [][COLS], int); //省略参数名，没问题
int sum2d(int (*ar)[COLS], int rows); // 指针表示法，另一种语法
```
上面每个函数都把ar视为内含数组元素（每个元素是内含4个int类型值的数组）的 数组。列数内置在函数体中，但是行数靠函数传递得到。
表示ar指向一个内含4个int类型值的数组（在我们的系统中，ar指向的 对象占16字节），所以ar+1的意思是“该地址加上16字节”。如果第2对方括 号是空的，编译器就不知道该怎样处理。
所以 `int sum2(int ar[][], int rows); // 错误的声明`

也可以在第1对方括号中写上大小，如下所示，但是编译器会忽略该 值：
`int sum2(int ar[3][4], int rows); // 有效声明，但是3将被忽略`

与使用typedef相比，这种形式方便得多：
```c
typedef int arr4[4]; // arr4是一个内含 4 个int的数组 
typedef arr4 arr3x4[3]; // arr3x4 是一个内含3个 arr4的数组 
int sum2(arr3x4 ar, int rows); // 与下面的声明相同
int sum2(int ar[3][4], int rows); // 与下面的声明相同
int sum2(int ar[][4], int rows); // 标准形式
```


一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中 的值：`int sum4d(int ar[][12][20][30], int rows);`
因为第1对方括号只用于表明这是一个指针，而其他的方括号用于描述指针所指向数据对象的类型。故下面的声明是等价的：
`int sum4d(int (*ar)[12][20][30])` //这里ar指向一个12*20*30的int数组。

## 变长数组 VLA
variable-length array

变长数组中的“变”不是指可以修改已创建数组的大小。
一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用 变量指定数组的维度。

例子
```c
int sum2d(int rows, int cols, int ar[rows][cols]);
int sum2d(int ar[rows][cols], int rows, int cols); // 无效的顺序
int sum2d(int, int, int ar[*][*]); // ar是一个变长数组（VLA），省略了维度 形参名
```

```c
// 带变长数组形参的函数
int sum2d(int rows, int cols, int ar[rows][cols]) 
{
    int tot = 0;
    for (int r = 0; r < rows; r++) 
        for (int c = 0; c < cols; c++) 
            tot += ar[r][c]; 
    return tot;
}
```

变长数组名实际上是一个指针。这说明带变长数 组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。

变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大 小。
普通 C数组都是静态内存分配，即在编译时确定数组的大小。由于数组 大小是常量，所以编译器在编译时就知道了。

对于传统的 C 数组，必须用常量表达式指明数组的大小，所以数组大 小在编译时就已确定。C99/C11新增了变长数组，可以用变量表示数组大 小。这意味着变长数组的大小延迟到程序运行时才确定。


## 复合字面量
C99新增了复合字面量 （compound literal）
发布C99标准的委员会认为，如果有代表数组和结构内容的复 合字面量，在编程时会更方便。


普通的数组声明： `int diva[2] = {10, 20};`

复合字面量创建` (int[2]){10, 20}; // 复合字面量`

时可以省略数组大小 ` (int []){50, 20, 90} // 内含3个元素的复合字面量`


使用指针记录为复合字面量地址
`int *pt1;`
`pt1 = (int[]){10, 20}; // *pt1是10，pt1[1]是20。`


把复合字面量作为实际参数传递给带有匹配形式参数的函数：
```
int sum(const int ar[], int n);
…
int total;
total = sum((int[]){4,4,5,5}, 4);
```
这种用法的好处是，把信息传入函数前不必先创建 数组，这是复合字面量的典型用法。

二维数组的复合字面量用法
`int (*pt2)[4]; `// 声明一个指向二维数组的指针，该数组内含2个数组 元素，
// 每个元素是内含4个int类型值的数组 
`pt2 = (int [2][4]) { {1,2,3,-9}, {4,5,6,-8} };`


