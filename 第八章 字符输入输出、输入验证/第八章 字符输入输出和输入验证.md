# 第八章 字符输入/输出和输入验证
## 缓冲区
无缓冲输入，即等待的程序可立即使用输入的字符。
缓冲区输入，输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。

ANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲 输入。如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提 供一个无缓冲输入的选项。

缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲 区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入 中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓 冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所 以在按下Enter键后才刷新缓冲区。

## 文件、流和键盘输入、文件结尾
C 是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件 
的库函数。从较低层面上， ~C可以使用主机操作系统的基本文件工具直接~ 
~理文件，这些直接调用操作系统的函数被称为底层 I/O （low-level I/O）。~ 
由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库， 
ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包 
（standard I/O package）来处理文件。这涉及创建用于处理文件的标准模型 
和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差 
异，以便用户使用统一的界面。 

上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。 
有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处；有些 
系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行 
符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。 
有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量。

如果使用标准 I/O 包，就不用考虑这些差异。因此，可以用 if (ch == ‘\n’)检查换行符。即使系统实际用的是回车符和换行符的组合来标记行 末尾，I/O函数会在两种表示法之间相互转换。

从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是 
一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的 
输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相 
关联，而且读写都通过流来完成。 

本章着重理解C把输入和输出设备视为存 储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的 文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、 printf()和scanf()函数都是标准I/O包的成员，处理这两个流。


文件结尾

计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的 
一种方法是，在文件末尾放一个特殊的字符标记文件结尾。操作系统可以使 
用内嵌的Ctrl+Z字符来标记文件结尾。这曾经是操作系统使用的唯一标记：
![](%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81/5E0C9217-6CD2-4AFD-99C2-73F28B3E37E2.png)

操作系统使用的另一种方法是储存文件大小的信息。如果文件有3000字 节，程序在读到3000字节时便达到文件的末尾。

~无论操作系统实际使用何种方法检测文件结尾~ ，在C语言中，用 
getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of 
File的缩写）。scanf()函数检测到文件结尾时也返回EOF。通常， EOF定义 
在stdio.h文件中： 
`#define EOF (-1) `

为什么是-1？因为getchar()函数的返回值通常都介于0～127，这些值对 
应标准字符集。但是，如果系统能识别扩展字符集，该函数的返回值可能在 
0～255之间。无论哪种情况，-1都不对应任何字符，所以，该值可用于标记 
文件结尾。 
某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符 
所产生的返回值不同。如果包含stdio.h文件，并使用EOF符号，就不必担心 
EOF值不同的问题。 ~这里关键要理解EOF是一个值，标志着检测到文件结~ 
~尾，并不是在文件中找得到的符号。~

使用EOF：`while((ch=getchar()) != EOF)`

键盘结束输入：Ctrl+D 、Ctrl+Z


## 重定向和文件

程序可以通过两种方式使用文件。第 1 种方法是，显式使用特定的函数 
打开文件、关闭文件、读取文件、写入文件，诸如此类。
第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把stdin流重新赋给文 件。继续使用getchar()函数从输入流中获取数据，但它并不关心从流的什么 位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单。

重定向输入
`echo_eof < words` 处理名为words的文本文件。<符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件 与stdin流相关联，把文件中的内容导入echo_eof程序。

重定向输出
`echo_eof > mywords` 创建mywords的新文件，然后把输出重定向至该文件中。

组合重定向
`echo_eof<mywords>savewords` 制作一份mywords文件的副本，并命名为savewords。
下面的命令也起作用，因为命令与重定向运算符的顺序无关： 
`echo_eof > savewords < mywords`

使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个 文件。

UNIX、Linux或Windows/DOS 还有>>运算符，该运算符可以把数据添加 到现有文件的末尾，而 | 运算符能把一个文件的输出连接到另一个文件的输 入。欲了解所有相关运算符的内容，请参阅 UNIX 的相关书籍

小结：如何重定向输入和输出 绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程 序，或只在C编译器允许的情况下重定向C程序。
假设prog是可执行程序 名，file1和file2是文件名。 
把输出重定向至文件：> 
prog >file1 
把输入重定向至文件：< 
prog <file2 
组合重定向： 
prog <file2 >file1 
prog >file1 <file2 
这两种形式都是把file2作为输入、file1作为输出。

 留白： 一些系统要求重定向运算符左侧有一个空格，右侧没有空格。而其他系 统（如，UNIX）允许在重定位运算符两侧有空格或没有空格。

## 输入验证

混合使用 getchar()和 scanf()时，如果在调用 getchar()之前，scanf()在输 入行留下一个换行符，会导致一些问题。不过，意识到这个问题就可以在程 序中妥善处理。
