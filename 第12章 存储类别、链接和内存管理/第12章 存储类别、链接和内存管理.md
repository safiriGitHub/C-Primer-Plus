# 第12章 存储类别、链接和内存管理
## 存储类别
### 作用域

作用域描述程序中可访问标识符的区域。一个C变量的作用域可以是块 作用域、函数作用域、函数原型作用域或文件作用域。

- 块作用域
{} 花括号、C99把块的概念扩展到包括for循环、while循环、 do while循环和if语句所控制的代码，即使这些代码没有用花括号括起来， 也算是块的一部分

- 函数作用域（function scope）仅用于goto语句的标签。

- 函数原型作用域（function prototype scope）
范围是从形参定义处到原型声明结束。
这意味着，编译器在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话） 通常无关紧要。
而且，即使有形参名，也不必与函数定义中的形参名相匹 配。
只有在变长数组中，形参名才有用：
` void use_a_VLA(int n, int m, ar[n][m]);`

- 文件作用域
变量的定义在函数的外面，具有文件作用域（file scope），从它的定义处到该定义所在文件的末尾均可见。
文件作用域变量也称为全局变量（global variable）。

描述一个具有文件作用域的变量时，它的实际可见范围 是整个翻译单元。
::翻译单元和文件:: 
C预处理实际上是用包含的头文件内容替换#include指令。
所以，编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元 （translation unit）。
如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。
每个翻译单元均对应一个源代码文件和它所包含的文件。

### 链接

C 变量有 3 种链接属性：外部链接、内部链接 或无链接。

具有块作用域、函数作用域或函数原型作用域的变量都是**无链接变量**。这意味着这些变量属于定义它们的块、函数或原型私有。

具有文件作用域的变量可以是外部链接或内部链接。
**外部链接变量**可以在多文件程序中使用，
**内部链接变量**只能在一个翻译单元中使用。

正式和非正式术语
C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源 代码文件和它所包含的头文件）的作用域，— 非正式：“文件作用域”
用“外部链接的文件作用域”描述 可延伸至其他翻译单元的作用域。— 非正式：“全局作用域”或“程序作用域”。

如何知道文件作用域变量是内部链接还是外部链接？可以查看外部定义中是否使用了存储类别说明符**static**： 
```c
int giants = 5; // 文件作用域，外部链接 :该文件和同一程序的其他文件都可以使用变量giants。

static int dodgers = 3; // 文件作用域，内部链接 :文件私有，只有该文件中的任意函数都可使用它。
int main() {… }
```

### 存储期

C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。

- 如果对象具有**静态存储期**，那么它在程序的执行期间一直存在。
文件作用域变量具有静态存储期。注意，对于文件作用域变量，关键字 static表明 了其链接属性，而非存储期。以 static声明的文件作用域变量具有内部链 接。但是 ~无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。~

- **线程存储期**用于并发程序设计，程序执行可被分为多个线程。具有线程 存储期的对象， ~从被声明时到线程结束一直存在~ 。以关键字**_Thread_local**声明一个对象时，每个线程都获得该变量的私有备份。

- 块作用域的变量通常都具有**自动存储期**。当程序进入定义这些变量的块 时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。 这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存 区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调 用函数的变量。
~变长数组稍有不同，它们的存储期从声明处到块的末尾~ ，而不是从块的 开始处到块的末尾。

然而， ~块作用域变量也能具有静态存储期~ 。为了创建这样的变量，要把 变量声明在块中，且在声明前面加上关键字static：
```c
void more(int number) {
    int index;
    static int ct = 0; 
    … 
    return 0;
}
```
这里，变量ct储存在静态内存中，它从程序被载入到程序结束期间都存在。但是，它的作用域定义在more()函数块中。只有在执行该函数时，程序才能使用ct访问它所指定的对象（但是，该函数可以给其他函数提供该存储区的地址以便间接访问该对象，例如通过指针形参或返回值）。

### 5种存储类别 
**自动、寄存器、静态块作用域、静态外部链接、静态内部链接**

![](%E7%AC%AC12%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/AFA81109-ADB8-45D8-8F9A-21D438FB33D9.png)

- 自动变量

属于 ~自动存储类别的变量具有自动存储期、块作用域且无链接~ 。默认情 
况下，声明在块或函数头中的任何变量都属于自动存储类别。为了更清楚地 
表达你的意图（例如，为了表明有意覆盖一个外部变量定义，或者强调不要 
把该变量改为其他存储类别），可以显式使用关键字**auto**，
 `auto int plox;`

关键字auto是存储类别说明符（storage-class specifier）。auto关键字在 C++中的用法完全不同， ~如果编写C/C++兼容的程序，最好不要使用auto作 为存储类别说明符~ 。

块作用域和无链接意味着只有在变量定义所在的块中才能通过变量名访 问该变量（当然，参数用于传递变量的值和地址给另一个函数，但是这是间 接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存 位置上的另一个变量。 变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存 在，程序在退出该块时变量消失。原来该变量占用的内存位置现在可做他 用。

初始化：
	自动变量不会初始化，除非显式初始化它。
```
int main(void)
{
int repid; 
int tents = 5;
```
	 tents变量被初始化为5，但是repid变量的值是之前占用分配给repid的空 间中的任意值（如果有的话），别指望这个值是0。


- 寄存器变量

变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在CPU 的寄存器中，或者概括地说，储存在最快的可用内存中。
与普通变量相比， 访问和处理这些变量的 ~速度更快~ 。
由于寄存器变量储存在寄存器而非内存 中，所以 ~无法获取寄存器变量的地址~ 。

绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。使用存储 类别说明符register便可声明寄存器变量：
```
int main(void)
{
register int quick;
```


我们刚才说“如果幸运的话”，是因为声明变量为register类别与直接命令 
相比更像是一种请求。
 ~编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿~ 。
在这种情况下， 寄存器变量就变成普通的自动变量。即使是这样， ~仍然不能对该变量使用地址运算符。~ 

在函数头中使用关键字register，便可请求形参是寄存器变量： 
`void macho(register int n) `
可声明为register的数据类型有限。
例如，处理器中的寄存器可能没有足够大的空间来储存double类型的值。


- 块作用域的静态变量

静态的意思是该变量在内存中原地不动，并不是说它的值不变。
文件作用域的变量自动具有（也必须是）静态存储期。
在块中（提供块作用域和无链接）以存储类别说明符static（提供静态存储期）声明使用局部静态变量

```c
/* loc_stat.c -- 使用局部静态变量 */
#include <stdio.h>
void trystat(void);

int main(void)
{
    int count;
    for (count = 1; count <= 3; count++)
    {
        printf("Here comes iteration %d:\n", count); 
        trystat();
    }
    return 0;
}

void trystat(void)
{
    int fade = 1;
    static int stay = 1;
    printf("fade = %d and stay = %d\n", fade++, stay++);
}

//每次调用trystat()都会初始化fade，但是stay只在编译 strstat()时被初始化一次。

int fade = 1;
//第1条声明确实是trystat()函数的一部分，每次调用该函数时都会执行这 条声明。这是运行时行为。

static int stay = 1;
//第2条声明实际上并不是trystat()函数的一部分。 如果逐步调试该程序会发现，程序似乎跳过了这条声明。
//这是因为静态变量 和外部变量在程序被载入内存时已执行完毕。
//把这条声明放在trystat()函数中是为了告诉编译器只有trystat()函数才能看到该变量。这条声明并未在运行时执行。
```

- 外部链接的静态变量

具有文件作用域、外部链接和静态存储期。也称为外部存储类别。

把变量的定义性声明（defining declaration）放在在所有函数的外面便创建了外部变量。
当然，为了指出该函数使用了外部 变量，可以在函数中用关键字**extern**再次声明。

如果一个源代码文件使用的 外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变 量。如下所示：
```c
int Errupt; /* 外部定义的变量 */ 
double Up[100]; /* 外部定义的数组 */ 
extern char Coal; /* 如果Coal被定义在另一个文件， */  //2:

/*则必须这样声明*/ 
void next(void); 
int main(void) 
{
//1:
extern int Errupt; /* 可选的声明*/ 
extern double Up[]; /* 可选的声明*/ 
...
}
void next(void)
{...}

//1: 解释
main()中的两条 extern 声明完 全可以省略，因为外部变量具有文件作用域，所以Errupt和Up从声明处到文 件结尾都可见。它们出现在那里，仅为了说明main()函数要使用这两个变 量。
如果省略掉函数中的extern关键字，相当于创建了一个自动变量。去掉下面声明中的extern： 
extern int Errupt; 
便成为： 
int Errupt; 
这使得编译器在 main()中创建了一个名为 Errupt 的自动变量。

//2:解释
如果一个源代码文件使用的 外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变量

```

在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域中的同 名变量。 ~如果不得已要使用与外部变量同名的局部变量，可以在局部变量的 声明中使用 **auto** 存储类别说明符明确表达这种意图~ 。

例子 外部变量的使用
```c 
int Hocus;
int magic();

int main(void)
{
int Hocus; //声明Hocus，默认是自动变量 属于main()私有
}
int Pucus; //外部变量的作用域是：从声明处到文件结尾。所以变量Pucus对于magic()可见，对main()不可见
int magic()
{
auto int Hocus; // 显式声明为自动变量 属于magic()私有
}
```


初始化外部变量：
```
如果未初始化外部变量，它们会被自动初始化为 0
int x = 10; // 没问题，10是常量 
int y = 3 + 20; // 没问题，用于初始化的是常量表达式 
size_t z = sizeof(int); //没问题，用于初始化的是常量表达式 （只要不是变长数组，sizeof表达式可被视为常量表达式。） 
int x2 = 2 * x; // 不行，x是变量
```


定义和声明
```
int tern = 1; //1
main()
{
	extern int tern;//2
}

//1 
第1次声明为变量预留了存储空间，该声明构成了变量的定义。称为定义式声明

//2
第2次声明只告诉编译器使用之前已创建的tern变量，所以 这不是定义。称为引用式声明。

```
总结：关键字 extern 表示该声明不是定义，指示编译器去别处查询其定义。

```
extern int tern; //❌ 不要用关键字extern创建外部定义，只用它来引用现有的外部定义。 
int main(void)
{

//file_one.c
char pe = 'N';

//file_two.c
extern char pe = 'Y'; //❌ 外部变量只能初始化一次，且必须在定义该变量时进行。

```

### 内部链接的静态变量

```
static int svil = 1; // 静态变量，内部链接 
int main(void)

```
只能用于同一个文件中的函数
可以使用存储类别说明符 extern，在函数中 重复声明任何具有文件作用域的变量。但这样的声明并不会改变其链接属性。

### 多文件

只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的 重要性。接下来简要介绍一下。 

复杂的C程序通常由多个单独的源代码文件组成。有时，这些文件可能要共享一个外部变量。C通过在一个文件中进行定义式声明，然后在其他文 件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他 声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。

注意，如果外部变量定义在一个文件中，那么其他文件在使用该变量之 前必须先声明它（用 extern关键字）。也就是说，在某文件中对外部变量进 行定义式声明只是单方面允许其他文件使用该变量，其他文件在用extern声 明之前不能直接使用它。

### 存储类别说明符

C 语言有6个关键字作为存储类别说明符：
`auto、register、static、extern、 _Thread_local、typedef`

**auto**说明符表明变量是自动存储期，只能用于块作用域的变量声明中。 由于在块中声明的变量本身就具有自动存储期，所以使用auto主要是为了明 确表达要使用与外部变量同名的局部变量的意图。

**register** 说明符也只用于块作用域的变量，它把变量归为寄存器存储类 别，请求最快速度访问该变量。同时，还保护了该变量的地址不被获取。  

**static** 说明符创建的对象具有静态存储期，载入程序时创建对象，当 程序结束时对象消失。如果static 用于文件作用域声明，作用域受限于该文 件。如果 static 用于块作用域声明，作用域则受限于该块。因此，只要程序 在运行对象就存在并保留其值，但是只有在执行块内的代码时，才能通过标识符访问。块作用域的静态变量无链接。文件作用域的静态变量具有内部链 接。

**extern** 说明符表明声明的变量定义在别处。如果包含 extern 的声明具有 文件作用域，则引用的变量必须具有外部链接。如果包含 extern 的声明具有 块作用域，则引用的变量可能具有外部链接或内部链接，这接取决于该变量 的定义式声明。

**_Thread_local**，它可以和static或extern一起使用
**typedef**关键字与任何内存存储无关，把它归于此类 有一些语法上的原因。


### 存储类别和函数

函数的存储类别：
外部函数 可以被其他文件的函数访问 `double gamma(double);`
静态函数 只能用于其定义所在的文件 `static double beta(int, int);`
内联函数 C99新增 

### 存储类别的选择

保护性程序设计的黄金法则是：“按需知道”原则。尽量在函数内部解决 该函数的任务，只共享那些需要共享的变量。除自动存储类别外，其他存储 类别也很有用。不过，在使用某类别之前先要考虑一下是否有必要这样做。

## 随机数函数和静态变量
ANSI C标准还提供了一个可移植的标准算法，在不同系统中生成相同的随机数。实际上，rand()是“ ~伪随机数生成器~ ”，意思是可预测生成数字的实际序列。但是，数字在其取值范围内均匀分布。

## 掷骰子
我们将要模拟一个非常流行的游戏——掷骰子。骰子的形式多种多样， 最普遍的是使用两个6面骰子。在一些冒险游戏中，会使用5种骰子：4面、6 面、8面、12面和20面。聪明的古希腊人证明了**只有5种正多面体，它们的所 有面都具有相同的形状和大小**。各种不同类型的骰子就是根据这些正多面体 发展而来。**也可以做成其他面数的，但是其所有的面不会都相等，因此各个 面朝上的几率就不同**。 
计算机计算不用考虑几何的限制，所以可以设计任意面数的电子骰子。 我们先从6面开始。 我们想获得1～6的随机数。然而，rand()生成的随机数在0～ RAND_MAX之间。RAND_MAX被定义在stdlib.h中，其值通常是 INT_MAX。因此，需要进行一些调整，方法如下。 
1.把随机数求模6，获得的整数在0～5之间。 
2.结果加1，新值在1～6之间。 
3.为方便以后扩展，把第1步中的数字6替换成骰子面数。 
下面的代码实现了这3个步骤：
```
static int rollem(int sides) /* 该函数属于该文件私有 */
{
    int roll;
    roll = rand() % sides + 1;
    return roll;
}
```

- - - -
## 分配内存：malloc() 和 free()

C可以在程序运行时分配更多的内存。
主要的工具是 malloc()函数，该函数接受一个参数：所需的内存字节数。malloc()函数会找 到合适的空闲内存块，这样的内存是**匿名的**。也就是说， malloc()分配内 存，但是不会为其赋名。
返回** ~动态分配内存块的首字节地址~ **。 因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。

因为 char表示1字节，malloc()的返回类型通常被定义为指向char的指针。
然而， 从ANSI C标准开始，C使用一个新的类型： ~**指向void的指针**~ 。该类型相当于 一个“通用指针”。
malloc()函数 ~可用于返回指向数组的指针、指向结构的指针等~ ，所以通常该函数的返回值会被强制转换为匹配的类型。
在ANSI C 中，应该坚持使用强制类型转换，提高代码的可读性。然而，把指向 void的指针赋给任意类型的指针完全不用考虑类型匹配的问题。
如果 malloc()分 配内存失败，将返回空指针。


例子1
```
double * ptd; 
ptd = (double *) malloc(30 * sizeof(double)); 
```

现在，我们有3种创建数组的方法。 
1、声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元 
素。可以用静态内存或自动内存创建这种数组。 
2、声明变长数组（C99新增的特性）时，用变量表达式表示数组的维度， 
用数组名访问数组的元素。具有这种特性的数组只能在自动内存中创建。 
3、声明一个指针，调用malloc()，将其返回值赋给指针，使用指针访问数 
组的元素。该指针可以是静态的或自动的。

```
使用第2种和第3种方法可以创建动态数组（dynamic array）

double item[n]; /* C99之前：n不允许是变量 */ 但是，可以这样做：
ptd = (double *) malloc(n * sizeof(double)); 
如你所见，这比变长数组更灵活
```

通常，malloc()要与free()配套使用。 ~free()函数的参数是之前malloc()返回的地址，该函数释放之前malloc()分配的内存。~
不能用 free()释放通过其他方式（如，声明一个数组）分配的内存。

另外，如果内存分配失败，可以调用 ~exit()函数结束程序~
标准提供了两个返回 值以保证在所有操作系统中都能正常工作：EXIT_SUCCESS（或者，相当于 0）表示普通的程序结束， EXIT_FAILURE 表示程序异常中止。一些操作系 统（包括 UNIX、Linux 和 Windows）还接受一些表示其他运行错误的整数 值。

程序示例
```c
/* dyn_arr.c -- 动态分配数组 */

#include <stdio.h>
#include <stdlib.h>  /* 为 malloc()、free()提供原型 */

int main(void)
{
    double *ptd;
    int max;
    int number;
    int i = 0;
    puts("What is the maximum number of type double entries?");
    if (scanf("%d", &max) != 1)
    {
        puts("Number not correctly entered -- bye.");
        exit(EXIT_FAILURE);
    }
    ptd = (double *)malloc(max*sizeof(double)); //1
    if (ptd == NULL) //2
    {
        puts("Memory allocation failed. Goodbye.");
        exit(EXIT_FAILURE);
    }
    /* ptd 现在指向有max个元素的数组 */
    puts("Enter the values (q to quit):");
    while (i < max && scanf("%lf", &ptd[i]) == 1)
    {
        ++i;
    }
    printf("Here are your %d entries:\n", number = i);
    for (i = 0; i < number; i++) 
    {
        printf("%7.2f ", ptd[i]); 
        if (i % 7 == 0) 
        putchar('\n'); 
    }

    if (i % 7 != 0) 
        putchar('\n'); 
    puts("Done.");
    
    free(ptd); //3
    return 0;
}

/*
1:
在C中，不一定要使用强制类型转换(double *)，但是在C++中必须使用。
所以，使用强制类型转换更容易把C程序转换为C++程序。


2:
malloc()可能分配不到所需的内存。在这种情况下，该函数返回空指 针，程序结束：

3:
一些操作系统在程序结束时会自动 释放动态分配的内存，但是有些系统不会。
为保险起见，请使用free()，不 要依赖操作系统来清理。
*/

```

### free() 的重要性  
	
防止内存泄漏

### calloc() 函数

```
long *newmem;
newmem = (long *)calloc(100, sizeof(long));
```
calloc()函数接受两个无符号整数作为参数（ANSI规定是size_t类 型）。
第1个参数是所需的存储单元数量，第2个参数是存储单元的大小（以 字节为单位）。

calloc()函数还有一个特性：它把块中的所有位都设置为0（注意，在某 些硬件系统中，不是把所有位都设置为0来表示浮点值0）。
free()函数也可用于释放calloc()分配的内存。

	
### 动态内存分配和变长数组
不同的是，变长数组是自动存储类型。因此，程序在离开变长数组定义 所在的块时（该例中，即vlamal()函数结束时）， ~变长数组占用的内存空间 会被自动释放，不必使用 free()。~

另一方面， ~用malloc()创建的数组不必局限在一个函数内访问~ 。例如，可以这样做：被调函数创建一个数组并返回指 针，供主调函数访问，然后主调函数在末尾调用free()释放之前被调函数分配的内存。另外， ~free()所用的指针变量可以与 malloc()的指针变量不同，但是两个指针必须储存相同的地址~ 。但是，不能释放同一块内存两次。


~对多维数组而言，使用变长数组更方便~
当然，也可以用 malloc()创建 二维数组，但是语法比较繁琐。
代码示例
```c
int n = 5;
int m = 6;

int ar2[n][m]; //nxm的变长数组（VLA）
int (*p2)[6]; //C99之前的写法
int (*p3)[m]; // 要求支持变长数组
p2 = (int (*)[6])malloc(n*6*sizeof(int)); //nx6数组
p3 = (int (*)[m])malloc(n*m*sizeof(int)); //nxm数组 （要求支持变长数组）
```

### 存储类别的内存分配
静态存储类别所用的内存数量在编译时确定，只要程序还在运行，就可 访问储存在该部分的数据。该类别的变量在程序开始执行时被创建，在程序 结束时被销毁。

自动存储类别的变量在程序进入变量定义所在块时存在，在程序 离开块时消失。这部分的内存通常作为栈来处理，这意味着新创 建的变量按顺序加入内存，然后以相反的顺序销毁。

动态分配的内存在调用 malloc()或相关函数时存在，在调用 free()后释 放。这部分的内存由程序员管理，而不是一套规则。所以内存块可以在一个 函数中创建，在另一个函数中销毁。正是因为这样， ~这部分的内存用于动态 内存分配会支离破碎。也就是说，未使用的内存块分散在已使用的内存块之 间~ 。另外， ~使用动态内存通常比使用栈内存慢~ 。

```
// where.c -- 数据被储存在何处？

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int static_store = 30;
const char *pcg = "String Literal";
int main()
{
    int auto_store = 40;
    char auto_string[] = "Auto char Array";
    int *pi;
    char *pcl;
    pi = (int *)malloc(sizeof(int));
    *pi = 35;
    pcl = (char *)malloc(strlen("Dynamic String") + 1);
    strcpy(pcl, "Dynamic String");

    printf(" 静态存储类别：\n");
    printf(" static_store: %d at %p\n", static_store, &static_store); 
    printf(" %s at %p\n", pcg, pcg); 
    printf(" %s at %p\n", "Quoted String", "Quoted String");

    puts("自动存储类别--------------");
    printf(" auto_store: %d at %p\n", auto_store, &auto_store);
    printf(" %s at %p\n", auto_string, auto_string); 

    puts("动态分配内存--------------");
    printf(" *pi: %d at %p\n", *pi, pi); 
    printf(" %s at %p\n", pcl, pcl); 
    
    free(pi);
    free(pcl);
    return 0;
}

/*
 静态存储类别：
 static_store: 30 at 0x104875038
 String Literal at 0x104870ec0
 Quoted String at 0x104870f2b
 自动存储类别--------------
 auto_store: 40 at 0x7ffeeb392528
 Auto char Array at 0x7ffeeb392530
 动态分配内存--------------
 *pi: 35 at 0x7ff0be405aa0
 Dynamic String at 0x7ff0be405ab0

 如上所示，静态数据（包括字符串字面量）占用一个区域，
 自动数据占 用另一个区域，
 动态分配的数据占用第3个区域（通常被称为内存堆或自由内存）。
*/
```

- - - -
- - - -
## ANSI C 类型限定符

**C90 ：const  和 volatile**
**C99 :  restrict**
**C11 :  _Atomic**

C99 为类型限定符增加了一个新属性：它们现在是幂等的 （idempotent）！这个属性听起来很强大，其实意思是可以在一条声明中多 次使用同一个限定符，多余的限定符将被忽略：
有了这个新属性，就可以编写类似下面的代码： 
typedef const int zip; 
const zip q = 8;

### const类型限定符

以const关键字声明的对象，其值不能通过赋值或递增、递减来修改。

- 在指针和形参声明中使用const
`const float *pt`  `float const *pt`
const放在*左侧任意位置，限定了指针指向的数据不能改变

`float *const pt`
const放在*的右侧，限定了指针本身不能改变，但指向的值可以改变

`const float * const ptr;` 
ptr既不能指向别处，它所指向的值也不能改变。

函数形参中使用：
`void display(const int array[], int limit);`
`char *strcat(char * restrict s1, const char * restrict s2);`

- 对全局数据使用const

在文件间共享const数据要小心。可以采用两个策略。
第一，遵 循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使 用引用式声明（用extern关键字）：
```c
/* file1.c -- 定义了一些外部const变量 */ 
const double PI = 3.14159; 
const char * MONTHS[12] = { "January", "February", "March", "April", "May", "June", "July","August", "September", "October", "November", "December" }; 

/* file2.c -- 使用定义在别处的外部const变量 */ 
extern const double PI; 
extern const * MONTHS [];
```

第二个方案是，把const变量放在一个头文件中，然后在其他文件中包 含该头文件：

```c
/* constant.h --定义了一些外部const变量*/ 
static const double PI = 3.14159; 
static const char * MONTHS[12] ={"January", "February", "March", "April", "May", "June", "July","August", "September", "October", "November", "December"}; 

/* file1.c --使用定义在别处的外部const变量*/ 
#include "constant.h" 

/* file2.c --使用定义在别处的外部const变量*/ 
#include "constant.h"
```


这种方案 ~**必须在头文件中用关键字static声明全局const变量**~ 。如果去掉 static，那么在file1.c和file2.c中包含constant.h将导致每个文件中都有一个相 同标识符的定义式声明，C标准不允许这样做。

实际上，这种方案相当于给每个文件提供了一个单独的数据副本[1]。
由于每个副本只对该文件可见，所以无法用这些数据和其他文件通信。不过没关 系，它们都是完全相同（每个文件都包含相同的头文件）的const数据（声 明时使用了const关键字），这不是问题。

头文件方案的好处是，方便你偷懒， ~不用惦记着在一个文件中使用定义 式声明，在其他文件中使用引用式声明~ 。所有的文件都只需包含同一个头文 件即可。但它的 **~缺点是，数据是重复的~** 。对于前面的例子而言，这不算什么 问题，但是如果const数据包含庞大的数组，就不能视而不见了。

### volatile 类型限定符

**volatile** 限定符告知计算机，**代理（ ~而不是变量所在的程序~ ）可以改变该变量的值**。通常，它被用于硬件地址以及在其他程序或同时运行的线程中 共享数据。例如，一个地址上可能储存着当前的时钟时间，无论程序做什 
么，地址上的值都随时间的变化而改变。或者一个地址用于接受另一台计算 
机传入的信息。

`volatile int loc1;`   

`volatile int* ploc;`

为何ANSI委员把volatile关键字放入标准？原因是它涉及编译器的优化。例如，假设有下面的代码：

vall = x;
/* 一些不使用 x 的代码*/
val2 = x;

智能的（进行优化的）编译器会注意到以上代码使用了两次 x，但并未 改变它的值。于是编译器把 x的值临时储存在寄存器中，然后在val2需要使 用x时，才从寄存器中（而不是从原始内存位置上）读取x的值，以节约时 间。这个过程被称为高速缓存（caching）。
通常，高速缓存是个不错的优化 方案，但是如果一些其他代理在以上两条语句之间改变了x的值，就不能这 样优化了。

volatile提醒编译器它后面所定义的变量随时都有可能改变， ~因此编译后的程序每次需要存储或读取这个变量的时候，都会直接**从变量地址中读取数据**~ 。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

volatile的本意是“易变的”,由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。比如：
![](%E7%AC%AC12%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20190619170238515.png)
程序的本意是希望ISR_2中断产生时，在main当中调用do_something函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致do_something永远也不会被调用。如果变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。
一般说来，volatile用在如下的几个地方：
1、中断服务程序中修改的供其它程序检测的变量需要加volatile；
2、多任务环境下各任务间共享的标志应该加volatile；
3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；
另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中可以禁止任务调度，3中则只能依靠硬件的良好设计了。

可以同时用const和volatile限定一个值。例如，通常用const把硬件时钟 设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。只 能在声明中同时使用这两个限定符，它们的顺序不重要，如下所示：
`volatile const int loc; `
`const volatile int * ploc;`

### restrict 类型限定符

restrict 关键字允许编译器优化某部分代码以更好地支持计算。它**只能用于指针，表明该指针是访问数据对象的 ~唯一且初始的~ 方式。**

- 用于变量

代码例子
```c
#include <stdio.h>

int main(void)
{
    int ar[10];
    int *par = ar;

    //这里，指针restar是访问由malloc()所分配内存的唯一且初始的方式。
    int *restrict restar = (int *)malloc(10*sizeof(int));
   
    for (int n = 0; n < 10; n++)
    {
        par[n] += 5;
        restar[n] += 5;
        ar[n] *= 2;
        par[n] += 3;
        restar[n] += 3;
    }

    //由于之前声明了 restar 是访问它所指向的数据块的唯一且初始的方式， 
    //编译器可以把涉及 restar的两条语句替换成下面这条语句，效果相同：
    restar[n] += 8;
    
    //但是，如果把与par相关的两条语句替换成下面的语句，将导致计算错误：
    par[n] += 8; / * 给出错误的结果 */
    //这是因为for循环在par两次访问相同的数据之间，用ar改变了该数据的值。

    在本例中，如果未使用restrict关键字，编译器就必须假设最坏的情况 
    （即，在两次使用指针之间，其他的标识符可能已经改变了数据）。
    如果用了restrict关键字，编译器就可以选择捷径优化计算。
}
```

- 用于函数形参中的指针

这意味着编译器可以假定在函数体内其他标识符 ~不会修改该指针指向的数据~ ，而且编译器可以尝试对 其优化，使其不做别的用途。例如，C 库有两个函数用于把一个位置上的字 节拷贝到另一个位置。在C99中，这两个函数的原型是：
`void * memcpy(void * restrict s1, const void * restrict s2, size_t n); `
`void * memmove(void * s1, const void * s2, size_t n);`

这两个函数都从位置s2把n字节拷贝到位置s1。
memcpy()函数要求两个 位置不重叠，但是memove()没有这样的要求。
声明s1和s2为restrict说明这两 个指针都是访问相应数据的唯一方式，所以它们不能访问相同块的数据。这 满足了memcpy()无重叠的要求。
memmove()函数允许重叠，它在拷贝数据时 不得不更小心，以防在使用数据之前就先覆盖了数据。

restrict 关键字有两个读者。一个是编译器，该关键字告知编译器可以 
自由假定一些优化方案。另一个读者是用户，该关键字告知用户要使用满足 
restrict要求的参数。总而言之，编译器不会检查用户是否遵循这一限制，但 
是无视它后果自负。


### _Atomic 类型限定符

当一个线程 对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。

int hogs;// 普通声明 
Hogs = 12; // 普通赋值 

可以替换成：

_Atomic int hogs; // hogs 是一个原子类型的变量 
atomic_store(&hogs, 12); // stdatomic.h中的宏

这里，在hogs中储存12是一个原子过程，其他线程不能访问hogs。


### 旧关键字的新位置

`void ofmouth(int * const a1, int * restrict a2, int n); // 以前的风格`

`void ofmouth(int a1[const], int a2[restrict], int n); // C99允许`

`void ofmouth(int a1[const], int a2[restrict], int n); // C99允许`


